# vim:ts=3:et:ft=conf:tw=0
#
# epic4 configuration
#
# uses no colors, only bold for emphasis.  looks nice on a monochrome terminal
# like a vt510.
#
# tabkey completion by <josh at hivehaus.org>, some other stuff ripped from
# jirc.
#
# all privmsg's go to window 1, so i advise you to create a new window when
# you connect and join the channel in window 2.  this way you won't miss any
# messages in the scrollback buffer if you haven't been paying attention for a
# while.
#

# aliases and functions

# do something in all of your channels
alias all {
	if (strlen($1)) {
		^local string;
		switch ( $0 ) {
			( a ) {
				quote privmsg $tr(/ /,/$mychannels()) :ACTION $1-;
				shook send_action * $1-
			}; ( m ) {
				quote privmsg $tr(/ /,/$mychannels()) :$1-;
				shook send_public * $1-
			}; ( n ) {
				quote notice $tr(/ /,/$mychannels()) :$1-;
				shook public_notice $N * $1-
			}
		}
	}
}
alias ame { all a }

alias away {
	if (strlen($0)) {
		//away $0-
	} else {
		//away
	}
}
alias back { //away }

alias ban { ^eval mode $C +b $0- }
alias bans { ^eval mode $C +b }
alias unban { ^eval mode $C -b $0 }

# update the status bar with our lag
alias checklag {
	setstatuslag ??;
	^on ^raw_irc "$S PONG $S :$N" {
		^on ^raw_irc -"$S PONG $S :$N";
		setstatuslag ${time()-checktime};
		timer -refnum lag $(status_lag_update) checklag
	};
	@ checktime = time();
	^quote ping $S
}
alias setstatuslag { ^set status_user2 $sar(/%2/$[-2]*/$status_lag  ) }

# quickly part and join a channel
alias cycle {
	@ :chan = $C;
	//part $chan;
	//join $chan;
}

alias deop { ^eval mode $C -oooo $0 $1 $2 $3 }
alias dop { ^eval mode $C -oooo $0 $1 $2 $3 }
alias op { ^eval mode $C +oooo $0 $1 $2 $3 }
alias dev { ^eval mode $C -vvvv $0 $1 $2 $3 }
alias devoice { ^eval mode $C -vvvv $0 $1 $2 $3 }
alias dv { ^eval mode $C -vvvv $0 $1 $2 $3 }
alias voice { ^eval mode $C +vvvv $0 $1 $2 $3 }

alias k {^eval kick $C $0 $1-}
alias kb {
	if (#) {
		quote mode $C -o+b $0 $mask(3 $userhost($0));
		//kick $C $0 $1-
	}
}

# quickly moderate the channel
alias mod { ^eval mode $C +m }

alias names { //who ${[$0]?[$0]:C} }
alias who { showchan }

alias new {
	window new hide;
	window next
}

alias wi { /whois $0 }

alias wn { window next }
alias wp { window previous }

alias umode { ^eval mode $N $0 }

alias untopic {quote TOPIC $C :}

# heh
alias save { xecho uh, no. }

# yummy tab key setup.
alias tk.addmsg {
  @ tk.matched = rmatch($0 $^\1-)
  if (tk.matched) {
    @ tk.msglist = [$(0-${tk.matched-1}) $(${tk.matched+1}-)]
    }
    { @ tk.msglist = [$(0-${tk.msgmax-1})] }
    @ tk.msgcnt = 0
    ^assign -tk.matched
}
alias tk.getmsg {
  @ tk.msgcnt = tk.msgcnt + [$0]
  if ( #tk.msglist < tk.msgcnt ) {@ tk.msgcnt = 1}
  if (tk.msgcnt <= 0) {@ tk.msgcnt =  #tk.msglist}
  @ tk.junk = K ## [msg]
  type ^U$tk.junk $^^{[$($tk.msgcnt)]} 
}
alias tk.delnick {
  if (tk.msgcnt == 0) {
    zecho $BTSX nickname: $word(0 $tk.msglist) removed
    @ tk.msglist = [$notword(1 $tk.msglist)]
  }{
    zecho $BTSX nickname: $word(${tk.msgcnt-1} $tk.msglist) removed
    @ tk.msglist = [$notword($tk.msgcnt $tk.msglist)]
  }
  type ^U
}

# server lag
assign status_lag [lag: %2]
assign status_lag_update 30

# keybindings
bind meta1-0 parse_command ^window swap 10
bind meta1-1 parse_command ^window swap 1
bind meta1-2 parse_command ^window swap 2
bind meta1-3 parse_command ^window swap 3
bind meta1-4 parse_command ^window swap 4
bind meta1-5 parse_command ^window swap 5
bind meta1-6 parse_command ^window swap 6
bind meta1-7 parse_command ^window swap 7
bind meta1-8 parse_command ^window swap 8
bind meta1-9 parse_command ^window swap 9

# sure.
alias 1 {^window swap 1}
alias 2 {^window swap 2}
alias 3 {^window swap 3}
alias 4 {^window swap 4}
alias 5 {^window swap 5}
alias 6 {^window swap 6}
alias 7 {^window swap 7}
alias 8 {^window swap 8}
alias 9 {^window swap 9}
alias 10 {^window swap 10}

# zip zip zip. -jjm
^bind ^I parse_command ^tk.getmsg 1 $tk.msglist
^bind ^R parse_command ^tk.getmsg -1 $tk.msglist

# *nod*
eval assign stamp [$Z]
set client_information always nothing
set banner ***

# yeah.
on ^connect "* *" { umode +iw; checklag; }

# formatting
on ^action '% $C *' { xecho [$Z] * $1!$0 $2- }
on ^action '* % *' { xecho [$Z] * $0 $2- }
on ^channel_nick "*" { xecho [$Z] $banner $0!$1 became $2. }
on ^channel_signoff "*" { xecho [$Z] $banner $0!$1 quit irc: \($2-\) }
on ^ctcp "*" { xecho -c [$Z] $banner $0 \($userhost()\) requested ctcp $2- from ${ [$1] == N ? [you] : [$1] }.}
on ^ctcp_reply "*" { xecho -c [$Z] $banner ctcp $1 reply from $0: $2- }
on ^join "*" { xecho [$Z] $banner $0 \($2\) has joined $1. }
on ^kick "*" { xecho [$Z] $banner $0 was kicked from $2 by $1 \($3-\) }
on ^leave "* *" { xecho [$Z] $banner $0 \($2\) has left $1. }
on ^mode "*" { xecho [$Z] $banner mode change "$2-" for $1 by $0. }
on ^msg "*" {
	xecho -w 1 [$Z] [$0\($userhost()\)] $1-
	^tk.addmsg $0 $tk.msglist
}
on ^nick "*" { xecho [$Z] $banner $0 became $1. }
on ^notice "*" { xecho -c [$Z] -$0\($userhost()\)- $1- }
on ^public '% % *$N*' { xecho [$Z] <$1!$0> $2- }
on ^public "* % *" { xecho [$Z] <$1!$0> $2- }
on ^send_action '$C *' { xecho [$Z] * $C!$N $1- }
on ^send_action "* *" { xecho [$Z] * $0:$N $1- }
on ^send_msg "*" {
	xecho -c [$Z] [msg\($0\)] $1-
	^tk.addmsg $0 $tk.msglist
}
on ^send_dcc_chat * {
	^tk.addmsg \=$0 $tk.msglist
}
on ^send_public '$C *' { xecho [$Z] <$0!$N> $1- }
on ^topic "* *" {
	if ([$2]) {
		xecho [$Z] $banner topic for $1 changed by $0: $2-
	} else {
		xecho [$Z] $banner topic for $1 unset by $0.
	}
}

# raw's

# whois
on ^301 "*" { xecho -c [$Z] *W* a: $1- }
on ^311 "*" {
	^hook header;
	xecho -c [$Z] *W* $1 \($2@$3\);
	xecho -c [$Z] *W* n: $5-
}
on ^312 "*" { xecho -c [$Z] *W* s: $2 \($3-\) }
on ^313 "*" { xecho -c [$Z] *W* o: $1 is an IRC Operator. }
on ^314 "*" {
	^hook header;
	xecho -c [$Z] *W* $1 was \($2@$3\);
	xecho -c [$Z] *W* n: $5-
}
on ^315 "*" {}
on ^317 "*" { xecho -c [$Z] *W* i: $tdiff2($2) }
on ^318 "*" {}
on ^319 "*" { xecho -c [$Z] *W* c: $2- }
on ^329 "*" {
	showchan
	xecho -c [$Z] $banner channel $1 created at $strftime($2 %A %B %d %T %Z %Y).
	assign lastcreate channel $1 created at $strftime($2 %A %B %d %T %Z %Y).
}
on ^331 "*" { xecho [$Z] $banner no topic set for $1. }
on ^332 "*" { xecho [$Z] $banner topic for $1: $2- }
on ^333 "*" { xecho [$Z] $banner topic set by $2 on $strftime($3 %D at %I:%M %Z).}
on ^353 "*" {}
on ^366 "*" {}
on ^369 "*" {}
on ^381 "*" { xecho -c [$Z] $banner $1- }
on ^401 "*" { xecho -c [$Z] $banner $1: no such nick or channel }
on ^406 "*" { xecho -c [$Z] $banner $1: no such nick or channel }
on ^471 "*" { xecho -c [$Z] $banner cannot join $1\; limit exceded (+l). }
on ^473 "*" { xecho -c [$Z] $banner cannot join $1\; must be invited (+i). }
on ^474 "*" { xecho -c [$Z] $banner cannot join $1\; banned (+b). }
on ^475 "*" { xecho -c [$Z] $banner cannot join $1\; wrong key (+k). }

# sets
set auto_rejoin off
set auto_whowas off
set beep_on_msg msgs
set clock_24hour on
set continued_line     
set help_path /usr/local/share/epic/help
set history 100
set input_prompt [$C] 
set lastlog 50000
set mail 0
set notify_on_termination off
set scrollback 5000
set status_away [away] 
set status_channel %C
set status_clock %T
set status_format [%T] [%*%=%@%N%#] %S%H%B%Q%A[%C%+%I%O]%F%L%D %W %> %2 %M[win: %R]
set status_mail [mail: %M]
set status_mode  (+%+)
set status_notify  [act: %F]
set status_umode  (+%#)
set status_user ircII-EPIC4
set status_user2 [lag:  0]

# yeah.
on ^set "STATUS_LAG *" {
	if ([$1]) {
		@ status_lag = [$1-];
		echo $banner value of STATUS_LAG set to $1-
	} else {
		echo $banner current value of STATUS_LAG is $(status_lag)
	}
}
on ^set "STATUS_LAG_UPDATE *" {
	if ([$1]) {
		if (isnumber($1)) {
			@ status_lag_update = [$1];
			echo $banner value of STATUS_LAG_UPDATE set to $1
		} else {
			echo $banner value of STATUS_LAG_UPDATE must be a number
		}
	} else {
		echo $banner current value of STATUS_LAG_UPDATE is $(status_lag_update)
	}
}

# stolen from jirc
alias xtitle {
	if (isconnected()) {
		xecho -r $chr(27)]2\;epic4: $N@$S$chr(7)
	} else {
		xecho -r $chr(27)]2\;$IRCNICK@<not registered yet>$chr(7)
	}
	parsekey refresh_screen
}

# this too
alias showchan {
	^local nicks
	@ :args = [$*]
	@ :chan = ischannel($tr( * # $0)) ? shift(args) : C
	@ nicks = fix.channel($chan)
	if (nicks) {
		@ :win = winchan($chan)
		fe ($nicks) n.1 n.2 n.3 n.4 {
			xecho -c [$Z] $banner $msar(g/@/@/+/+/./ /[$[11]n.1] [$[11]n.2] [$[11]n.3] [$[11]n.4])
      }
   }
}

# and this (sorts things)
alias fix.channel {
	@ function_return = tr(/!/@/$sort($msar(g/@?/!/@+/!/@./!/.+/+/.././$channel($0))))
}
